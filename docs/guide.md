## LB-IGD 비개발자용 사용 설명서

> 목표: “게임을 직접 많이 플레이해서 감으로 밸런스를 맞추는 것” 대신,  
> 컴퓨터가 self-play를 반복해서 **승률이 50:50에 가까워지도록** 규칙/맵/말을 자동으로 조정하게 한다.

---

## 0. 이 프로젝트가 하는 일(한 문장)
LB-IGD는 “체스 같은 격자 전투 게임”에서 **맵(크기/장애물) + 팩션별 말(개수/행마/사거리/공격 패턴/스탯)**을 설계변수로 두고, self-play 통계를 기반으로 밸런스를 자동 최적화한다.

---

## 1. 비개발자 관점에서 중요한 개념 5개
### 1.1 “설계(Design)”가 뭔가?
여기서 설계는 “룰을 바꾸는 것”이다. 예를 들어:
- 맵을 12x12에서 14x14로 바꾼다
- 장애물을 더 넣거나 배치 패턴을 바꾼다
- P0는 폰을 8개, P1은 폰을 6개로 바꾼다
- 룩을 장거리로 만들지, 근접으로 만들지 정한다(사거리/공격 패턴)

### 1.2 “self-play”가 뭔가?
같은 규칙으로 양쪽 AI를 학습시키고, 서로 계속 붙여서 결과를 모은다.  
그래서 사람이 “이 규칙이 공평한지” 감으로 판단하지 않아도 된다.

### 1.3 “승률 50:50”이 왜 기준인가?
2팩션(1:1) 기준으로 가장 단순한 밸런스 목표는 “한 쪽이 꾸준히 이기지 않는 것”이다.  
즉 P0 승률 $W\approx 0.5$.

### 1.4 “LB(Laplace–Beltrami)”는 여기서 무엇인가?
LB-IGD에서 LB는 설계공간의 승률장 $P(x)$가 너무 뾰족해지는(=작은 설계 변화에 승률이 급변하는) 방향을 억제하는 정규화로 사용된다.  
이건 “운 좋게 맞은 밸런스”보다 “조금 바꿔도 잘 유지되는 튼튼한 밸런스”를 선호하게 만든다.

### 1.5 “시드(seed)”가 왜 중요하냐?
학습과 게임은 확률적이다. 같은 설계라도 결과가 흔들릴 수 있다.  
그래서 여러 시드로 돌려 평균/분산을 보는 것이 중요하다.

---

## 2. 지금 이 레포에서 “체스 같은 게임”은 어떻게 표현되나
### 2.1 맵
- `width`, `height`: 보드 크기
- `obstacle_density`: 장애물 밀도(0이면 없음)
- `obstacle_pattern`: 장애물 배치 패턴(0~3)
  - 0: 없음
  - 1: 좌우 대칭 랜덤 산포
  - 2: 중앙 장벽(통로 포함)
  - 3: 중앙 집중 대칭 산포

장애물은:
- 이동 착지 불가
- 슬라이딩 이동 경로를 막음
- 슬라이딩 공격의 시야를 막음

### 2.2 말 타입(유닛 타입)
기본 타입은 `unit0~unit4` + `king`(왕)이다.

`main.py`의 “체스형 프리셋”은 다음처럼 매핑한다:
- `unit0` = pawn(폰)
- `unit1` = rook(룩)
- `unit2` = knight(나이트)
- `unit3` = bishop(비숍)
- `unit4` = queen(퀸)
- `king` = king

### 2.3 “행마 패턴(move pattern)”
이동은 `*_pattern`으로 정한다. 값은 0~11.
- 0: 직선 슬라이딩(상하좌우)
- 1: 대각 슬라이딩
- 2: 전방향 슬라이딩(8방향)
- 3: 전방향 점프
- 4: 나이트 점프
- 5: 카멜 점프(3+1)
- 6: 제브라 점프(3+2)
- 7: 엘리펀트(대각 2칸 점프)
- 8: 다바바(직선 2칸 점프)
- 9: 직선 점프
- 10: 대각 점프
- 11: 전진 슬라이딩(폰 스타일, 진영 방향 반영)

추가로 `*_move`는 “이동 거리/점프 반복 횟수”에 해당한다.

### 2.4 “공격 패턴(attack pattern)”
공격은 `*_attack_pattern`으로 정한다. 값은 0~12.
- 0~11: 이동 패턴과 동일한 방향 집합(슬라이딩/점프 포함)
- 12: pawn 대각 공격(진영 방향 반영)

`*_range`는 “공격 사거리”로 사용되며,
- 슬라이딩 공격은 장애물/유닛에 막히는 “시야” 규칙이 적용된다.

---

## 3. 실행 방법(비개발자용)
### 3.1 설치
1) Python 3.12 이상 설치  
2) 아래 명령 실행

```bash
pip install uv
uv sync
```

### 3.2 실행 모드 2가지
이 레포는 `main.py`가 두 가지 모드를 가진다.

#### (A) 설계 “평가(evaluate)” 모드 (기본)
현재 설정된 설계(예: 체스형 프리셋)를 여러 시드로 학습/대전해서 승률 통계를 출력한다.

```bash
.venv/Scripts/python main.py
```

#### (B) 설계 “최적화(optimize)” 모드
ES(black-box optimizer)가 설계변수를 바꿔가며 밸런스를 맞춘다.

```bash
.venv/Scripts/python main.py --opt
```

#### (C) 더 느리지만 더 안정적인 평가
학습/평가 에피소드와 시드 수를 늘려 결과 흔들림을 줄인다.

```bash
.venv/Scripts/python main.py --slow
```

---

## 4. 출력 해석(무엇을 보면 되나)
### 4.1 평가 모드 출력
- `p0_win_mean`: P0 평균 승률(0.5에 가까울수록 밸런스)
- `p0_win_var`: 시드에 따른 승률 흔들림(작을수록 강건)
- `draw_mean`: 무승부 비율(너무 높으면 “퇴화” 가능)
- `avg_dist_mean`: 공격 발생 평균 거리(메타/플레이 패턴 힌트)

### 4.2 최적화 모드 출력
각 step에서:
- `Loss`: 현재 설계의 손실(작을수록 목표에 가까움)
- `P0/P1/Draw/Dist`: 대전 통계
- `LBO=... w=...`: 설계공간 라플라시안(곡률) 크기와 업데이트 가중치  
  - 곡률이 큰 방향은 `w`가 작아져 업데이트가 약해진다(불안정한 설계를 덜 타게 함)

---

## 5. “내가 원하는 규칙”을 넣는 방법(중요)
비개발자 기준으로 가장 쉬운 방법은 `main.py`에서 `chess_design`(평가용) 또는 `initial_design`(최적화용)의 숫자를 바꾸는 것이다.

바꿀 수 있는 대표 항목:
- 맵: `width`, `height`, `obstacle_density`, `obstacle_pattern`
- 말 개수: `p0_unit*_units`, `p1_unit*_units`
- 이동: `p*_unit*_pattern`, `p*_unit*_move`
- 공격: `p*_unit*_attack_pattern`, `p*_unit*_range`
- 스탯: `p*_unit*_hp`, `p*_unit*_damage`

권장 순서:
1) 먼저 “평가 모드”로 원하는 설계를 넣고 승률을 본다
2) 그 다음 “최적화 모드”로 자동 밸런싱을 돌린다

---

## 6. 주의사항(현실적인 한계)
- 학습 예산(episodes)이 너무 작으면 “둘 다 약해서 50:50”이 나올 수 있다.  
  그래서 `--slow` 같은 더 큰 예산 평가가 필요할 때가 있다.
- 장애물이 너무 많으면 교전 자체가 사라지는 퇴화가 발생할 수 있다.
- 이 도구는 “밸런스 조정”에 강하지만 “재미/전략 깊이”를 자동 보장하지는 않는다.


